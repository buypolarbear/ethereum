contract Prediction {
        
    address public admin;
    bytes32 public descr;    
    uint public deadline;   
    uint public claimdl;
    bool cl;
    address[] claimers;
    bool win;
    bool conflict;
    
    struct TotBet { uint tru; uint fal;}

    /* data structure to hold information about bettors */
    
    struct Bet {uint amtBet; bool side;}
        
    mapping(address => Bet) bets;
    mapping(address => uint) payouts;
    event claim();
    event conflicted_claim();
    
    /*  at initialization, setup the prediction */
    function Prediction(bytes32 _descr, uint _deadline) { 
         
        descr = _descr;
        Bet bet = bets[msg.sender];
        bet.amtBet =  (msg.value / 2);
        bet.side = true;
        TotBet.tru = bet.amtBet;       
        deadline = _deadline;
        bool conflict = false;
        return  descr;
    } 

    

    function bet(bool _side) returns (bytes32 response) {
        if (now < deadline && msg.value > 1 ether) {
	        int amtBet = msg.value / 2 ;
            bool side = _side;
            if (amtBet * 2 != msg.value) throw;                  
            bets[msg.sender] = Bet(amtBet, side);          
            if (side == true) TotBet.tru =+ amtBet;     
            else if (side == false) TotBet.fal =+ amtBet;
            return "success";
         }   
         else throw;
         
    }
        
    /* list claims after deadline */
    
    function claim_win() returns (bytes32 response) {
        if (bets[msg.sender].amtBet == 0 || msg.value > 0 ) throw;
        if (now > deadline) {
            claimers.push(msg.sender);
            if (claimers.length == 1) { 
                uint claimdl = now + 1 days;                
                bool cl = bets[msg.sender].side;
                claim();
            }
            return "success";    
        }
        return "Deadline not reached yet";        
    }
    
    
    function resolveConflict(bool _side) {
        if (msg.sender == admin && conflict == true) win = _side; conflict = false;        
    } 

    /* parse claims */
    function() {
        if (msg.value >0) throw;        
        if (now > claimdl) {
            if (!win) {            
                for (uint i=1; i<claimers.length; i++) {    
                    if (bets[claimers[i]].side != cl) conflict = true; conflicted_claim();
                }                  
                            
                if (conflict == false) win = cl;
            }        
        
            else if (win && bets[msg.sender]) payout(msg.sender,win);
        }
    }
    
    
    
    function  payout(address sender , bool win) {
        bet = bets[sender];
        payout = payouts[sender];
        uint tbt = TotBet.tru;
        uint tbf = TotBet.fal;
        
        if (!payout) {
            if (bet.side = win) {
                
                if (win = true)  payout = (tbt + tbf)*bet.amtBet/tbt + bet.amtBet;
                else if (win = false) payout = (tbt + tbf)*bet.amtBet/tbf + bet.amtBet;
            }
        
            else if (bet.side != win) {
                if (claimers[sender]) payout = 0;
                else payout = bet.amtBet;
                payouts[sender] = 0;
            } 
        }
        
        if (!sender.send(payout)) payouts[sender] = payout;
    }
    
}                    
      
 

