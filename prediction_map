contract Prediction {
        
    address public admin;
    bytes32 public descr;    
    uint public deadline;   
    uint public claimdl;
    bool cl;
    address[] claimers;
    bool win;
    bool conflict;
    
    /* data structure to hold information about bettors */
    
    struct Bet {uint amtBet; bool side;}
    uint[] tb = new uint[](2);
    
    mapping(address => Bet) bets;
    mapping(address => uint) payouts;
    event claim();
    event conflicting_claim();
    //event announce_win(win);
    //event setUp(Bet);
    
    /*  at initialization, setup the prediction */
    
    function Prediction(bytes32 _descr, uint _deadline) { 
        descr = _descr;
        Bet bet = bets[msg.sender];
        bet.amtBet = msg.value/2; bet.side = true;
        tb[0] = bet.amtBet; tb[1] = 0;       
        deadline = _deadline;
        bool conflict = false;
    } 

    function bet(bool _side) returns (bytes32 response) {
        if (now < deadline && msg.value > 1 ether) {
	        uint amtBet = msg.value/2 ;
            bool side = _side;
            if (amtBet * 2 != msg.value) throw;
            if (side == true) tb[0] =+ amtBet;     
            else if (side == false) tb[1] =+ amtBet;
            bets[msg.sender] = Bet(amtBet, side);          
            
            return "success";
         }   
         else throw;
         
    }
        
    /* list claims after deadline */
    
    function claim_win() returns (bytes32 response) {
        if (bets[msg.sender].amtBet == 0 || msg.value > 0 ) throw;
        if (now > deadline) {
            claimers.push(msg.sender);
            if (claimers.length == 1) { 
                uint claimdl = now + 1 days;                
                bool cl = bets[msg.sender].side;
                claim();
            }
            return "success";    
        }
        return "Deadline not reached yet";        
    }
    
    
    function resolveConflict(bool _side) {
        if (msg.sender == admin && conflict == true) win = _side; conflict = false;        
    } 

    /* parse claims */
    bool lock = false;
    function() {
        if (msg.value >0 && !lock) throw;        
        if (now > claimdl) {
            if (!win) {
                bool cl = bets[claimers[0]].side;
                for (uint i=1; i<claimers.length; i++) {
                    if (bets[claimers[i]].side != cl) { 
                        conflict = true; 
                        conflicting_claim();
                        return;
                    }    
                }
                if (conflict == false) {
                    win = cl;
                }
            }
        }
    lock = true;
    }
    
    function  payout() {
        if (!conflict) {
            address sender = msg.sender;
            Bet bet = bets[sender];
            uint tbt = tb[0];
            uint tbf = tb[1];
            if (bet.side = win) {
                if (win = true)  payouts[sender] = (tbt + tbf)*bet.amtBet/tbt + bet.amtBet;
                else if (win = false) payouts[sender] = (tbt + tbf)*bet.amtBet/tbf + bet.amtBet;
            }
            else if (bet.side != win) {
                //if (claimers[ != 0) payout = 0;
                payouts[sender] = bet.amtBet;
            }
        }
        uint po = payouts[sender];
        payouts[sender] = 0;
        if (!sender.send(po)) payouts[sender] = po;
    }
    
}                    
      
 

