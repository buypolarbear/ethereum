pragma solidity ^0.4.0;
contract EthEx {
    uint public price;
    uint public ethForSale;
    uint public ethToBuy;
    address public seller;
    address public buyer;
    enum State { Open, Locked, Inactive }
    State public state;
    function EthEx(uint _price) payable {
        price = _price;
        seller = msg.sender;
        ethForSale = msg.value / 2;
        if (2 * ethForSale != msg.value) throw;
    }
    modifier require(bool _condition) {
        if (!_condition) throw;
        _;
    }
    modifier onlyBuyer() {
        if (msg.sender != buyer) throw;
        _;
    }
    modifier onlySeller() {
        if (msg.sender != seller) throw;
        _;
    }
    modifier inState(State _state) {
        if (state != _state) throw;
        _;
    }
    event aborted();
    event purchaseConfirmed();
    event cashReceived();
    event priceChanged(uint price);
    function abort()
        onlySeller
        inState(State.Open)
    {
        aborted();
        state = State.Inactive;
        if (!seller.send(this.balance)) throw;
    }
    function confirmPurchase()
        inState(State.Open)
        require(msg.value <= ethForSale)
        require((msg.value * price/100) % 50 == 0)
        payable
    {
        purchaseConfirmed();
        buyer = msg.sender;
        ethToBuy = msg.value;
        state = State.Locked;
    }
    function confirmReceived()
        onlySeller
        inState(State.Locked)
    {
        cashReceived();
        state = State.Inactive;
        if (!buyer.send(ethToBuy * 2))  throw;
        ethForSale = this.balance / 2;
        ethToBuy = 0;
        state = State.Open;
    }
    function addEther() 
        onlySeller
        inState(State.Open)
        payable
    {
        ethForSale = this.balance / 2;
    }
    function changePrice(uint _price) 
        onlySeller
        inState(State.Open)
    {     
        price = _price;
        priceChanged(price);
    }    
    function get_stat() returns (State, uint, uint, uint, uint) {return (state, price, ethForSale, ethToBuy, this.balance);}
    function() { throw;}
}
